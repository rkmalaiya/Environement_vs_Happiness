---
title: "All Countries Environmental Data"
output:
  word_document: default
  html_notebook: default
  pdf_document: default
---


```{r include=FALSE, results='hide'}
# Installing required packages
# sudo apt-get install libcairo2-dev
# sudo apt-get install libxml2-dev

devtools::install_github('HerveAbdi/PTCA4CATA')
library(corrplot)
library(ExPosition)
library(InPosition)
library(animation)
library(dplyr)
library(ggplot2)
library(RColorBrewer)
library(gplots)
library(PTCA4CATA)
library(purrr)
library(tidyr)

```


## Method: MCA

Multiple correspondence analysis (MCA) is an extension of correspondence analysis(CA) which allows one to analyze the pattern of relationships of several categorical dependent variables. As such, it can also be seen as a generalization of principal component analysis when the variables to be analyzed are categorical instead of quantitative. Because MCA has been (re)discovered many times, equivalent methods are known under several different names such as optimal scaling, optimal or appropriate scoring, dual scaling, homogeneity analysis,scalogram analysis, and quantiÔ¨Åcation method.

**Interpreting MCA**
Multiple correspondence analysis locates all the categories in a Euclidean space.

* The first two dimensions of this space are plotted to examine the associations among the categories. 
* The top-right quadrant of the plot shows the categories.
* The bottom-left quadrant shows the association.
* This interpretation is based on points found in approximately the same direction from the origin and in approximately the same region of the space. Distances between points do not have a straightforward interpretation.


## Dataset

```{r include=FALSE, results='hide'}
country_env_df = read.csv('../dataset/World_countries_env_vars.csv')
country_env_df_for_corr = country_env_df[, !names(country_env_df) %in% c('Country')]

country_env_df$Happiness_Rank = cut(country_env_df$Happiness_Rank,breaks = c(0, 39,118, 159), right=TRUE, labels = c('VH' , 'H', 'U'),ordered_result = TRUE)
```

* Data: Measurements of environment conditions in Countries
* Rows: There are 137 observations, 1 for each country.
* Columns: Total 29 variables
 + Qualitative: Country (nominal), Happiness (Ordinal).
 + Quantitative: Aspect, Slope Crop Land, Tree Canopy Wind Cloud & Multiple variables for Temp & Rain

* Structure of Data

```{r data_summary}
str(country_env_df)
```


* Research Question

How do the 137 countries differ on these variables?

## Analysis 

Let's observe the distribution of each variables to get an intuition of how we can bin these variables. It's important to have nearly equal number of observations in the each bin and to try to cut the variables in a way to so that each new binned distribution is nearly Gaussian. We can also verify that our binning is appropiate by calculating Spearman Correlation for each of original variable and binned variable, the correlation coefficient should be close to 1.

```{r echo=FALSE}

country_env_df_for_pca = country_env_df[, !names(country_env_df) %in% c('Country', 'Happiness_Rank')]

rownames(country_env_df_for_corr) <- paste0(country_env_df[,'Country'], '(' ,country_env_df[,'Happiness_Rank'], ')')
rownames(country_env_df_for_pca) <- paste0(country_env_df[,'Country'], '(' ,country_env_df[,'Happiness_Rank'], ')')

```

### Histogram
```{r echo=FALSE}

#str(country_env_df_for_pca)
country_env_df_for_pca %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_histogram(bins=30)

```

### Density plot
```{r echo=FALSE}

#str(country_env_df_for_pca)
country_env_df_for_pca %>%
  keep(is.numeric) %>% 
  gather() %>% 
  ggplot(aes(value)) +
    facet_wrap(~ key, scales = "free") +
    geom_density()

```

### Binning

We will use cut method with 4 quartile intervals for each variable to get binned version of each variable.

```{r}

cut_r <- function(x, b = 4, label=c(1,2,3,4) ) {
  c <- cut(x,breaks = b, labels = label)
  #h <- hclust(dist(sort(country_env_df_for_pca[,1])),"median")
  #c <- cutree(h, k = b)
  return (factor(c))
}

country_env_df_for_mca = lapply(country_env_df_for_pca, cut_r, )
country_env_df_for_mca <- as.data.frame(country_env_df_for_mca)
str(country_env_df_for_mca)
```

### Spearman Correlation
```{r}

for (i in 1:ncol(country_env_df_for_mca)){
  print(paste(colnames(country_env_df_for_mca)[i], "--Correlation--", cor(as.integer(country_env_df_for_mca[,i]),as.integer(country_env_df_for_pca[,i]),method = "spearman")))
}
```


### Correlation Plot
Visually analyze multicollinearity in the system. 

```{r}
corr_result = cor(country_env_df_for_corr)
corrplot(corr_result,order = 'hclust', addrect = 7)
```

## Identify Latent Components - MCA (With Inference)


```{r pca, echo=FALSE, results='hide', message=FALSE}

country_env_mca <- epMCA(DATA = country_env_df_for_mca, DESIGN = country_env_df$Happiness_Rank, graphs = FALSE,symmetric = TRUE)
country_env_mca_a <- epMCA(DATA = country_env_df_for_mca, DESIGN = country_env_df$Happiness_Rank, graphs = FALSE, symmetric = FALSE)

country_env_mca_inf <- InPosition::epMCA.inference.battery(DATA = country_env_df_for_mca, DESIGN = country_env_df$Happiness_Rank, graphs = FALSE)


col_palate = brewer.pal(n = 12, name='Set3')
  
col4J = vector('list', nrow(country_env_mca$ExPosition.Data$fj))
col4J[grep('rain',rownames(country_env_mca$ExPosition.Data$fj))] = col_palate[1]
col4J[grep('temp',rownames(country_env_mca$ExPosition.Data$fj))] = 'red' #col_palate[2]
col4J[sapply(col4J, 'is.null')] = col_palate[3:11]
```

### Scree Plot
Gives amount of information explained by corresponding component. Gives an intuition to decide which components best represent data in order to answer the research question.

P.S. The most contribution component may not always be most useful for a given research question. 


```{r}

PTCA4CATA::PlotScree(ev = country_env_mca$ExPosition.Data$eigs,
                      p.ev =  country_env_mca_inf$Inference.Data$components$p.vals,
                      title = 'SCREE Plot',
                      plotKaiser = TRUE
)

```

### Factor Scores 

Lets visualize happiness categories for components 1-10, to make a decision (visually) on the most important components.


```{r echo=FALSE}


list_color <- c('#305ABF' = 'burlywood3', '#84BF30' = 'royalblue1', '#BF30AD' = 'springgreen4')
happy_levels <- c('Happy', 'Happier', 'Happiest')

country_env_mca$Plotting.Data$fi.col[,1] <- recode (country_env_mca$Plotting.Data$fi.col, !!!list_color)

groups_of_data <- vector('list', 3)

col = country_env_mca$Plotting.Data$fi.col
fi = country_env_mca$ExPosition.Data$fi
j = 1
color_filter = col == unique(col)[1]
groups_of_data[[j]] = color_filter
j = j + 1

color_filter = col == unique(col)[2]
groups_of_data[[j]] = color_filter
j = j + 1

color_filter = col == unique(col)[3]
groups_of_data[[j]] = color_filter
j = j + 1

country_env_mca_mean = aggregate(x=country_env_mca$ExPosition.Data$fi, by = split(col, col(col)), FUN = mean)
rownames(country_env_mca_mean) <- happy_levels

country_env_mca_mean <- country_env_mca_mean[-1]

```

**With Confidence Interval**
```{r echo=FALSE}
BootCube.Gr <- PTCA4CATA::Boot4Mean(country_env_mca$ExPosition.Data$fi, 
                                    design = country_env_df$Happiness_Rank,
                                    niter = 1000,
                                    suppressProgressBar = TRUE)
for(i in c(1,3,5,7, 9)) {
  axis1 = i
  axis2 = i+1

  country_factor_map <- PTCA4CATA::createFactorMap(country_env_mca$ExPosition.Data$fi, title='', 
                                                 col.points = country_env_mca$Plotting.Data$fi.col,
                                                 col.labels = country_env_mca$Plotting.Data$fi.col,
                                                 axis1 = axis1,
                                                 axis2 = axis2,
                                                 display.labels = FALSE)

country_factor_map_mean <- PTCA4CATA::createFactorMap(country_env_mca_mean,
                                                 col.points = unique(country_env_mca$Plotting.Data$fi.col),
                                                 col.labels = unique(country_env_mca$Plotting.Data$fi.col),
                                                 axis1 = axis1,
                                                 axis2 = axis2,
                                                 display.labels = TRUE,
                                                 cex = 8,alpha.points = 0.8)

country_label4Map <- PTCA4CATA::createxyLabels.gen(axis1,axis2,lambda = country_env_mca$ExPosition.Data$eigs, tau = country_env_mca$ExPosition.Data$t) 



country_map = country_factor_map$zeMap + country_label4Map + country_factor_map_mean$zeMap_dots + country_factor_map_mean$zeMap_text


GraphElli <- PTCA4CATA::MakeCIEllipses(BootCube.Gr$BootCube[,c(axis1, axis2),],
                                       names.of.factors = c(paste("Dimension",axis1), paste("Dimension",axis2)),
                                       col = unique(country_env_mca$Plotting.Data$fi.col),
                                       p.level = .95
)

country_map = country_map + GraphElli

print(country_map)
}

```


**With Tolerance Interval**

```{r echo=FALSE}

for(i in c(1,3,5,7, 9)) {
  axis1 = i
  axis2 = i+1

country_factor_map <- PTCA4CATA::createFactorMap(country_env_mca$ExPosition.Data$fi, title='', 
                                                 col.points = country_env_mca$Plotting.Data$fi.col,
                                                 col.labels = country_env_mca$Plotting.Data$fi.col,
                                                 axis1 = axis1,
                                                 axis2 = axis2,
                                                 display.labels = FALSE)

country_factor_map_mean <- PTCA4CATA::createFactorMap(country_env_mca_mean,
                                                 col.points = unique(country_env_mca$Plotting.Data$fi.col),
                                                 col.labels = unique(country_env_mca$Plotting.Data$fi.col),
                                                 axis1 = axis1,
                                                 axis2 = axis2,
                                                 display.labels = TRUE,
                                                 cex = 8,alpha.points = 0.8)

country_label4Map <- PTCA4CATA::createxyLabels.gen(axis1,axis2,lambda = country_env_mca$ExPosition.Data$eigs, tau = country_env_mca$ExPosition.Data$t) 



country_map = country_factor_map$zeMap + country_label4Map + country_factor_map_mean$zeMap_dots + country_factor_map_mean$zeMap_text


GraphTI.Hull <- PTCA4CATA::MakeToleranceIntervals(country_env_mca$ExPosition.Data$fi[,c(axis1, axis2)],
                                                  design = country_env_df$Happiness_Rank,
                                                  # line below is needed
                                                  names.of.factors =  c("Dim1","Dim2"), # needed 
                                                  col = unique(country_env_mca$Plotting.Data$fi.col),
                                                  line.size = .50, 
                                                  line.type = 3,
                                                  alpha.ellipse = .2,
                                                  alpha.line    = .4,
                                                  p.level       = .75)

country_map = country_map + GraphTI.Hull

print(country_map)


}

```


We will proceed by making Symmetric and Asymmetric plots for Components 1,2,7,9.

```{r echo=FALSE, results='hide'}
loop <- matrix(data = c(1,2, 7,9), nrow = 2, ncol = 2, byrow = TRUE)
color4Authors <- country_env_mca$Plotting.Data$fi.col
Fi <- country_env_mca$ExPosition.Data$fi
Fj <- country_env_mca$ExPosition.Data$fj
Fj.a <- country_env_mca_a$ExPosition.Data$fj
```

#### Symmetric Plot
```{r}

for (i in 1:2){
  axis1 = loop[i,1]
  axis2 = loop[i,2]
  
  symMap  <- createFactorMapIJ(Fi,Fj,
                               col.points.i = color4Authors,
                               col.labels.i = color4Authors,
                               col.points.j = col4J,
                               col.labels.j = col4J, pch.j = 8, cex.j = 5, axis1 = axis1, axis2 = axis2)
  
  
  labels4CA <- PTCA4CATA::createxyLabels.gen(axis1,axis2,lambda = country_env_mca$ExPosition.Data$eigs, tau = country_env_mca$ExPosition.Data$t) #createxyLabels(resCA = country_env_mca )
  
  
  map.IJ.sym <- symMap$baseMap  + symMap$I_points + #+ symMap$I_labels+symMap$J_labels
      symMap$J_points + labels4CA
  print(map.IJ.sym)
}
```

#### Asymmmetric Plot
```{r}
for (i in 1:2){
  asymMap  <- createFactorMapIJ(Fi,Fj.a,
                                col.points.i = color4Authors,
                                col.labels.i = color4Authors,
                                col.points.j = col4J,
                                col.labels.j = col4J, pch.j = 8, cex.j = 5, )
  
  labels4CA <- PTCA4CATA::createxyLabels.gen(axis1,axis2,lambda = country_env_mca$ExPosition.Data$eigs, tau = country_env_mca$ExPosition.Data$t) #createxyLabels(resCA = country_env_mca)
  
  axis1 = loop[i,1]
  axis2 = loop[i,2]
  
  map.IJ.asym <- asymMap$baseMap + #asymMap$I_labels + 
    asymMap$I_points + #asymMap$J_labels + 
    asymMap$J_points + labels4CA
  print(map.IJ.asym)
}
```




#### Most Contributing Variables (Inference)

Let's plot variable contributions against each chosen components i.e. 1, 2, 7, 9.

* With Bootstrap Ratio

```{r}

BR <- country_env_mca_inf$Inference.Data$fj.boots$tests$boot.ratios

for (i in c(1, 2, 7, 9)) {
  laDim = i
  ba001.BR1 <- PrettyBarPlot2(BR[,laDim],
                              threshold = 2,
                              font.size = 5,
                              color4bar = gplots::col2hex(col4J), # we need hex code
                              main = paste0('Bootstrap ratio ',laDim),
                              ylab = 'Bootstrap ratios',horizontal = FALSE
                              #ylim = c(1.2*min(BR[,laDim]), 1.2*max(BR[,laDim]))
  )
  print(ba001.BR1)
}
```

